= Java switch-case internals

Switch-case statements are internally implemented with either `tableswitch` or `lookupswitch` bytecode instructions. Both instructions function by popping the stack for an integer value, and selecting a jump offset associated with the popped value.

== The `tableswitch` instruction

The `tableswitch` instruction is a variable length instruction used for selecting and executing a jump based on a jump-table defined over a sorted, continous list of possible integer values. Tool, such as javap, might represent the `tableswitch` instruction textually in ways similar to the following example.

[source]
----
tableswitch   { // 3 to 5
    3: 50
    4: 39
    5: 28
    default: 61
}
----

The instruction described above will pop the stack for an integer value and for values ranging from 3 to 5 perform a jump to the noted program address. For values outside the defined 3 to 5 range, the instruction will preform a jump to the address noted under the default label. Note, that the actual bytecode instruction uses relative offset values rather than the absolute addresses reported by javap.

The bytecode structure of the `tableswitch` instruction is as follows:

[cols=",100%"]
|===
|Data type |Description

|ubyte8    |`tableswitch` opcode (0xAA)
|-         |Padding of (0-3) bytes so that the start of the default jump offset field falls on a address, which is a multiple of 4.
|uint32    |Default jump offset
|uint32    |Low value
|uint32    |High value    
|uint32    |Jump offset 1, associated with value _low_
|...       |...
|uint32    |Jump offset n, associated with value _high_ (_low_ + n - 1)
|===

The operations performed by the execution of the `switchtable` instruction can be illustrated with the following pseudo-code.

[source,java]
----
int value = pop();
if (value < lowValue || value > highValue) {
    pc += defaultOffset;
} else {
    pc += jumpOffset[value - lowValue];
}
----

The `pop()` expression in the above code represents the instruction popping the stack for an integer value and the `pc` variable stands for the _program counter_ register, storing the address of the next instruction to be executed by the JVM.

== The `lookupswitch` instruction

The `lookupswitch` instruction is used performing branching based on a list of key-offset pairs. This instruction is not as fast as `tableswitch` instruction, but allows branching on a list of individual values, rather than continous ranges of values. This branching instruction essentially trades computational efficiency for space efficiency in cases where the branching must be performed on a sparse non-continous set of values.

A sample `lookupswitch` as printed by javap might look something like the following:

[source]
----
lookupswitch { // 3
    0: 36
    1: 47
    500: 58
    default: 69
}
----

This instruction will pop the stack for an integer value, then will search it's list of key-jump offset pairs for a matching value. The list of pairs are sorted by key to allow a better-than-linear searching.

If a matching key is found in the list, a jump will be performed using the associated jump offset. I case no matching key is found, the instruction will instead perform a jump based on the default jump offset of the instruction.

Note, that the actual bytecode instruction uses relative offset values rather than the absolute addresses reported by javap.

The bytecode structure of the `lookupswitch` instruction is as follows:

[cols=",100%"]
|===
|Data type |Description

|ubyte8    |`lookupswitch` opcode (0xAB)
|-         |Padding of (0-3) bytes so that the start of the default jump offset field falls on a address, which is a multiple of 4.
|uint32    |Default jump offset
|uint32    |Number of key-offset pairs
|uint32    |Value of key 1
|uint32    |Jump offset for key 1
|...       |...
|uint32    |Value of key n
|uint32    |Jump offset for key n
|===

== Choosing the right switch instruction

When compiling a given switch statement the java compiler has to make a decision between either emitting a `tableswitch` or a `lookupswitch` instruction. This decision is based on the time/space complexity costs associated with each instruction.

The compiler will stick with the `tableswitch` instruction as long as the space and time costs for doing so are lower or equal to the cost of using `lookupswitch`.

The table used for calculating space/time costs for the two instruction types is the following:

|===
|Opcode        |Space cost       |Time cost

|`tableswitch` |4 + (hi - lo + 1)|3
|`lookupswitch`|3 + 2 * nlabels  |nlabels
|===

The _hi_ and _lo_ parameters are the highest and lowest value switch keys used in the switch statement and _nlabels_ is the number of switch keys.

The overall space/time cost of using a specific instruction is calculated by using the formula: `spaceCost + timeCost * 3`.

== Using `tableswitch` over a non-continous ranges of keys

Choosing between `tableswitch` and `lookupswitch` based on space/time cost analysis can lead to situations where a `tableswitch` instruction needs to operate over a non-continous range of key values. The compiler will resolve this problem by filling in the gaps between the sparse keys with jumps to the default label of the switch statement.

See the following `lookupswitch` instruction over the sparse value set of 0, 1, 3 and 5 as an example.

[source]
----
lookupswitch   { // 4
    0: 40
    1: 51
    3: 62
    5: 73
    default: 84
}
----

By inserting values 2 and 4 as jumps to the default offset (84), the instruction can be converted into a semantically equivalent `tableswitch` instruction:

[source]
----
tableswitch   { // 0 to 5
    0: 40
    1: 51
    2: 84   // dummy case
    3: 62
    4: 84   // dummy case
    5: 73
    default: 84
}
----

Using a `tableswitch` instead of a `lookupswitch` in cases such as these is a decision to trade the space efficiency provided by sparse keys for the constant time lookup of a table-based approach.

== Implementing java switches over numeric values

TODO

== Implementing java switches over String values

TODO

== Implementing java switches over Enum values

TODO
